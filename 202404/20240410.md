# 오브젝트 책 읽기 스터디
# 7. 객체 분해

## 0. 서론

### 장기 기억과 단기 기억

- 장기 기억: 용량이 무한대, 평생에 걸쳐 보관하는 저장소, 직접 접근 불가
- 단기 기억: 직접 접근 가능, 용량 한정

- 단기 기억에서 병목 현상이 발생함

- **인지 과부하(cogitive overload)**: 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 경우
- 인지 과부하를 방지하는 가장 좋은 방법은 추상화를 통해 정보의 핵심만 남기는 것
  - 큰 문제를 작은 문제로 나누는 작업을 **분해(decomposition)**라고 한다.

- 추상화를 통해 인간이 인지할 수 있는 영역까지 복잡한 문제를 쪼갤 수 있다.
  - 이를 통해 아무리 어려운 문제여도 해결해왔다.

## 1. 프로시저 추상화와 데이터 추상화

- 프로그래밍 언어의 발전은 추상화를 통해 복잡성을 극복하려는 개발자들의 노력에서 나왔다.
  - 기계어 -> 어셈블리어 -> 고수준 언어

- 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.
- 두 가지 추상화 매커니즘
  - **프로시저 추상화(procedure abstraction)**: 소프트웨어가 무엇을 해야 하는지를 추상화한다.
  - **데이터 추상화(data abstraction)**: 소프트웨어는 무엇을 알아야 하는지를 추상화한다.
- 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다.

- 시스템을 분해하는 방법을 결정하려면 두 가지 추상화 매커니즘 중 무엇을 중심으로 할 지 결정해야 한다.
  - 프로시저 중심의 시스템 분해: **기능 분해(functional decomposition)**, **알고리즘 분해(algorithmic decomposition)**
  - 데이터 중심의 시스템 분해: **타입을 추상화(type abstraction)**, **프로시저를 추상화(procedure abstraction)**
    - 타입 추상화를 **추상 데이터 타입(Abstract Data Type)**, 프로시저 추상화를 **객체지향(Object-Oriented)**이라고 부른다.

- 프로그래밍 언어의 관점에서 객체지향: 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용하여 시스템을 분해하는 것
  - 이를 구현하기 위해 클래스라는 도구를 제공한다.
  - 클래스는 데이터 추상화와 프로시저 추상화를 함께 포함한다.

## 2. 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

- 초기에는 기능을 기준으로 시스템을 분해했다.
  - 이와 같은 시스템 분해 방식을 알고리즘 분해, 기능 분해라고 부른다.
- 추상화의 단위는 프로시저, 시스템은 프로시저를 단위로 분해된다.

- 프로시저도 인터페이스만 알면 상세한 구현 내용을 모르더라도 사용할 수 있기 때문에 추상화라고 부른다.
  - 하지만 프로시저만으로 효과적인 정보은닉을 하기에는 한계가 있다.

- 프로시저 중심의 기능 분해 관점에서 시스템은 입력 값을 계산해서 출력 값을 반환하는 하나의 커다란 메인 함수다.
  - 메인 함수는 더 작은 함수들로 나눠진다.
  - **하향식 접근법(Top-Down Approach)**: 최상위 기능을 정의하고 이를 좀 더 작은 단위의 하위 기능으로 분해하는 것

### 급여 관리 시스템

- 기능 분해를 위한 하향식 접근법은 먼저 필요한 기능을 생각하고 이 기능을 분해하고 정제한다.
  - 이 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다.
- 이는 유지보수에 다양한 문제를 일으킨다.

### 급여 관리 시스템 구현

- 하향식 기능 분해 방식으로 설계한 시스템은 메인 함수를 루트로 하는 트리(tree) 구조로 표현할 수 있다.
  - 각 노드는 시스템을 구성하는 하나의 프로시저
  - 자식 노드는 부모 노드를 구현하는 절차 중 한 단계를 의미

### 하향식 기능 분해의 문제점

- 설계는 코드 배치 방법이다.
- 설계가 필요한 이유는 변경에 대비하기 위해서이다.
- 하향식 접근법과 기능 분해는 변경에 취약한 설계를 낳는다.

**시스템은 하나의 메인 함수로 구성돼 있지 않다.**

- 시스템은 시간이 지나며 새로운 기능을 추가하게 된다.
  - 최초에 배포된 메인 함수 모습을 그대로 유지하지 않는다.

- 대부분의 시스템에서 하나의 메인 기능이라는 개념은 존재하지 않는다.
- 하향식 접근법은 하나의 알고리즘을 구현하기에는 적합하지만 현대적인 시스템을 개발하기에는 적합하지 않다.

**메인 함수의 빈번한 재설계**

- 하향식 기능 분해는 새로운 기능을 추가할 때마다 메인 함수를 수정해야 한다.
- 기능을 추가할 때마다 기존 코드가 빈번하게 수정되기 때문에 시스템은 변경에 취약해진다.

**비즈니스 로직과 사용자 인터페이스의 결합**

- 하향식 접근법은 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.
- 하지만 비즈니스 로직과 사용자 인터페이스는 변경되는 빈도가 다르다.
  - 사용자 인터페이스는 시스템 내에서 가장 자주 변경되는 부분이다.
  - 비즈니스 로직인 사용자 인터페이스에 비해 변경이 적다.
- 따라서 하향식 접근법은 근본적으로 변경에 불안정한 아키텍쳐를 만든다.

**성급하게 결정된 실행 순서**

- 하향식 접근법은 설계를 시작하는 시점부터 시스템이 무엇(what)을 해야 하는지보단 어떻게(how) 동작해야 하는지에 집중한다.
  - 처음부터 구현을 염두에 둔다.
- 모든 문제의 원인은 **결합도**다.
  - 구현 시점의 문맥에 강하게 결합된다.
  - 새로운 문맥이 생겼을 때 재사용하기 어렵다.

**데이터 변경으로 인한 파급 효과**

- 하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것이다.
  - 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.
- 어떤 데이터가 어떤 함수에 의존하고 있는지를 파악하기는 어렵다.
  - 모든 함수를 열어 데이터를 사용하고 있는지 확인해봐야 한다.

- 데이터의 수정이 일어나면 그 데이터와 연관되어 있는 모든 함수를 찾아 변경해야 한다.
  - 이를 찾는 것은 운의 영역이다.
  - 모든 로직을 변경해야 하고, 미처 변경하지 못한 부분이 있을 경우 버그로 이어진다.
- 데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것은 쉽지 않다.

- 변경에 대한 영향을 최소화하기 위해서는 영향을 받는 부분과 받지 않는 부분을 명확하게 분리해야 한다.
  - 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶기
  - 외부에서는 제공되는 함수만 이용해 데이터에 접근해야 한다.

### 언제 하향식 분해갸 유용한가?

- 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다.
- 그러나 하향식은 새로운 것을 개발하고, 설계하고, 발견하는 데는 적합한 방법이 아니다.
- 하향식 단계는 문제가 이미 해결됐고, 해결해야 하는 세부사항만이 존재할 때 시작해야 한다.

- 하향식 분해는 커다란 소프트웨어를 설계하는 데 적합한 방법은 아니다.

## 3. 모듈

### 정보 은닉과 모듈

- 변경의 방향에 맞춰 시스템을 분해하자.

- **정보 은닉(information hiding)**
  - 시스템을 모듈 단위로 분해하기 위한 기본 원리
  - 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다는 것

- 모듈과 기능 분해는 상호 배타적인 관계가 아니다.
  - 시스템을 모듈로 분해 -> 각 모듈 내부를 구현하기 위해 기능 분해
- 기능 분해: 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정
- 모듈 분해: 감춰야 하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정

- 모듈은 다음 두 가지 비밀을 감춰야 한다.
  - 복잡성: 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해 모듈의 복잡도를 낮춘다.
  - 변경 가능성: 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.

### 모듈의 장점과 한계

- 모듈의 장점
  - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
  - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
  - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염(namespace pollution)을 방지한다.

- 모듈은 외부에 감춰야 하는 비밀과 관련성 높은 데이터와 함수의 집합이다.
  - 모듈 내부는 높은 응집도를 유지하고, 외부와는 낮은 결합도를 유지한다.

- 모듈은 감춰야 할 데이터를 결정하고 이를 조작하는 데 필요한 함수를 결정한다.
- 그러나 태생적으로 변경을 관리하기 위한 구현 기법이기 때문에 추상화 관점에서 한계가 명확하다.
  - 인스턴스의 개념을 제공하지 않는다.
  - 이를 만족시키기 위해 나온 개념이 추상 데이터 타입

## 4. 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

- **타입(type)**: 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수를 의미
- 절차형 언어들은 적은 수의 내장 타입만을 제공했다.
  - 이 때 주로 사용할 수 있는 추상화는 프로시저 추상화였다.

- **데이터 추상화(data abstraction)**
  - 추상 객체의 클래스를 정의한 것
  - 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가짐

- 추상 데이터 타입을 구현하기 위한 프로그래밍 언어의 지원
  - 타입 정의를 선언할 수 있어야 한다.
  - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
  - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
  - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

- 모듈은 전체 대상을 캡슐화한다.
- 추상 데이터 타입은 개별 대상의 인스턴스를 생성할 수 있다.

- 추상 데이터 타입의 기본 의도는 프로그래밍 언어가 제공하는 타입을 사용자가 추가할 수 있게 하는 것이다.
- 그렇다면 클래스는 추상 데이터 타입일까?

## 5. 클래스

### 클래스는 추상 데이터 타입인가?

- 대부분의 서적은 클래스를 추상 데이터 타입으로 설명한다.
  - 두 매커니즘 보두 외부에서는 객체 내부 속성에 접근할 수 없고, 퍼블릭 인터페이스를 통해서만 외부와 의사소통할 수 있다.
- 명확한 의미에서 추상 데이터 타입과 클래스는 동일하지 않다.
  - 클래스는 상속과 다형성을 지원하지만 추상 데이터 타입은 지원하지 못한다.

- **객체지향 프로그래밍(Object-Oriented Programming)**: 상속과 다형성을 지원
- **객체기반 프로그래밍(Object-Based Programming)**: 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반 프로그래밍

- 추상 데이터 타입은 **타입을 추상화한 것(type abstraction)**
  - 오퍼레이션을 기준으로 타입을 나눈다.
- 클래스는 **절차를 추상화한 것(procedural abstraction)**
  - 타입을 기준으로 오퍼레이션을 묶는다.

### 변경을 기준으로 선택하라

- 클래스를 구현단위로 사용한다고 해서 객체지향이 아니다.
  - 타입을 기준으로 절차를 추상화해야 객체지향 분해다.

- 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있으면 객체지향을 위반한다.
- 객체지향에서는 타입 변수 대신 다형성을 사용한다.
  - Replace Type Code with Class
- 클라이언트가 객체의 타입을 확인하는 것이 아닌 객체가 메시지를 처리할 메서드를 선택한다.
  - 시스템에 새로운 로직을 추가하기 위해 클라이언트의 코드를 수정할 필요가 없어진다.

- 개방-폐쇄 원칙(Open-Closed Principle, OCP)
  - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성

- 추상 데이터 타입과 객체지향 설계는 변경의 압력이 어디에 있느냐에 따라 갈린다.
- 타입 추가라는 변경의 압력이 강한 경우 객체지향을 선택하자.
  - 추상 데이터 타입은 새로운 타입을 추가할 때 타입을 체크하는 코드를 일일이 찾아 수정해야 한다.
  - 객체지향은 클라이언트의 코드를 수정할 필요가 없다.
- 오퍼레이션 추가라는 변경의 압력이 강한 경우 추상 데이터 타입을 고르자.
  - 객체지향의 경우 새로운 오퍼레이션을 추가하기 위해 상속 계층에 속하는 모든 클래스를 수정해야 한다.
  - 추상 데이터 타입의 경우 구현 코드가 하나의 구현체 내에 있기 때문에 추가하는 작업이 간단하다.
- 변경의 축을 찾아 구조를 선택하자.
  - 객체지향적인 접근법이 모든 경우에 올바른 해결 방법은 아니다.

- 모듈과 추상 데이터 타입은 데이터 중심적 관점(data centered view)
- 객체지향은 서비스 중심적 관점(service centered view)

### 협력이 중요하다.

- 타입 계층과 다형성은 협력이라는 문맥 안에서 책임을 수행하는 방법에 대해 고민한 결과물이어야 한다.
- 도구 자체가 목적이 되어서는 안된다.
