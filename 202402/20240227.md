## 운영체제 스터디

### busy waiting

- 싱글 코어인 경우 하나의 쓰레드가 busy wait에 걸리면, 그 쓰레드가 cpu를 점유하게 될텐데 어떻게 그 상태를 해결할 수 있을까?
    - 함수가 atomic하기 때문에 busy wait 도중에 interrupt를 걸 수 없다.
    - 라운드로빈 같은 context switch도 일어나지 않을 것 같다.

## Readers-Writers 문제

- 여러개의 프로세스들이 공유 자원에 접근하는 상황
    - 몇개의 프로세스는 읽기만 하고, 몇개의 프로세스는 읽고 쓰기를 다 함
    - 두 개 이상의 reader들이 동시에 공유 자원에 접근하는 경우 문제가 생길까? → 생기지 않음
    - writer는 공유 자원에 접근하는 경우 문제가 생김
- 해결 방법
    - 먼저 접근하는 프로세스에게 접근 권한을 줄 수 있음 → writer가 기다려야 함
    - writer가 먼저 접근하는 방법
    - 두 방법 모두 starvation이 발생한다

### Reader-Writer Locks

- read 모드 write 모드를 선택할 수 있음

## 뱅커 알고리즘

### 뱅커 알고리즘은 왜 데드락을 회피하는 알고리즘일까?

- 회피: 데드락 상태가 발생하는 것을 미리 예방하는 것
- 해결: 이미 발생한 데드락 상태를 감지하고 해결
    - 프로세스를 종료, 자원을 강제 회수하여 다른 프로세스에게 할당, 롤백

이진 세마포어와 뮤텍스에 차이가 있나?

- 세마포어는 전역변수이기 때문에 다른 쓰레드가 1을 올려 해제할 수 있음
- 뮤텍스는 소유권 개념이기에 다른 쓰레드가 해제할 수 없음

데드락 조건 중 hold and wait

- 작업을 시작하기 위해 필요한 자원이 두 개 이상일 때 하나의 자원만 가진 채로 다른 자원을 기다리는 상태

lock free - wait free?

함수형 프로그래밍에서 Thread Safe를 보장하는 방법은?

### **데이터의 불변성(Immutability)**

- **불변 객체 사용**: FP에서는 데이터가 불변이므로, 한 번 생성된 데이터는 변경될 수 없습니다. 이는 공유 자원에 대한 동시 접근이 있더라도 데이터가 변경되지 않기 때문에 데이터 일관성과 스레드 안전성이 자동으로 보장됩니다.

### **순수 함수(Pure Functions)**

- **순수 함수**: FP의 함수는 순수 함수라는 개념을 따릅니다. 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하며, 사이드 이펙트를 발생시키지 않습니다. 이는 함수의 결과가 오직 입력 값에만 의존하며 외부 상태에 의존하지 않기 때문에, 여러 스레드에서 동시에 해당 함수를 호출해도 서로의 실행 결과에 영향을 미치지 않아 스레드 안전성을 보장합니다.

### **고차 함수와 함수 합성(Function Composition)**

- **함수 합성과 고차 함수 사용**: FP에서는 고차 함수(higher-order functions)와 함수의 합성을 통해 로직을 구성합니다. 이러한 방식은 데이터 흐름을 명확하게 하며, 사이드 이펙트를 최소화합니다. 고차 함수는 다른 함수를 인자로 받거나 함수를 결과로 반환하는 함수로, 이를 통해 생성된 새로운 함수 역시 순수 함수의 특성을 유지함으로써 스레드 안전성을 보장합니다.

### **지역성(Local Reasoning)**

- **지역성 강화**: FP는 지역성(local reasoning)을 강조합니다. 프로그램의 어떤 부분을 이해하기 위해 전역 상태나 다른 컨텍스트를 알 필요가 없습니다. 이는 프로그램의 예측 가능성과 이해도를 높이며, 동시에 여러 스레드에서 동작할 때 발생할 수 있는 복잡성과 스레드 간의 상호작용 문제를 줄입니다.

어떤 데이터를 병렬적으로 정렬하려고 할 때 어떤 알고리즘이 효과적일까요?

- 병합 정렬?