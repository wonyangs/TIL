# 오브젝트 책 읽기 스터디
# 2장 - 객체지향 프로그래밍

## 0. 서론

- 책 전반에 걸쳐 반복적으로 참고하게 될 영화 예메 시스템의 도메인을 설명
  - 도메인에 대해 객체지향적으로 작성한 코드를 소개
- 2장을 읽고 나면 객체지향 프로그래밍에서 사용되는 다양한 요소와 개념을 함께 이해할 수 있을 것
- 가벼운 마음가짐을 가지고 다양한 주제들을 얕게 살펴보기

## 1. 영화 예매 시스템

### 요구사항 살펴보기

- 사용자는 온라인 영화 예매 시스템을 이용해 보고 싶은 영화를 예매할 수 있다.

### 용어 구분

- 영화: 영화에 대한 기본 정보. 제목, 상영시간, 가격 정보 등이 영화에 포함
- 상영: 실제로 관객들이 영화를 관람하는 사건. 상영 일자, 시간, 순번 등을 가리킴
- 하나의 영화는 하루 중 다양한 시간대에 걸쳐 한 번 이상 상영될 수 있음

- 용어의 차이가 중요한 이유
  - 사용자가 실제로 예매하는 대상은 영화가 아닌 상영임
  - 사람들은 영화를 예매한다고 표현하지만, 실제로는 특정 시간에 상영되는 영화를 관람할 수 있는 권리를 구매

### 요금 할인

- 할인 조건(discount condition): 가격 할인의 여부를 결정
  - 순서 조건(sequence condition): 상영 순번을 이용해 할인 여부를 결정
  - 기간 조건(period condition): 영화 상영 시작 시간을 이용해 할인 여부를 결정
- 할인 정책(discount policy): 할인 요금을 결정
  - 금액 할인 정책(amount discount policy): 예매 요금에서 일정 금액을 할인
  - 비용 할인 정책(percent discount policy): 정가에서 일정 비율의 요금을 할인

- 영화별로 하나의 할인 정책만 할당할 수 있음
  - 할인 정책을 지정하지 않는 것도 가능
- 할인 조건은 다수의 할인 조건을 함께 지정할 수 잇음
  - 순서 조건과 기간 조건을 섞는 것도 가능

### 할인 적용

- 할인 조건과 할인 정책을 조합하여 할인을 적용한다.
  - 할인 조건을 만족하는 경우 할인 정책을 이용해 할인 요금을 계산한다.
  - 할인 조건을 만족하지 못하는 경우나 할인 정책이 적용돼 있지 않은 경우 할인을 적용하지 않는다.
- 할인 정책은 1인을 기준으로 책정된다.

## 2. 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스

- 객체지향은 객체를 지향하는 것이다.
- 대부분의 사람들은 **클래스(class)** 를 결정한 후 클래스에 어떤 속성과 메서드가 필요한지 고민한다.
  - 이는 객체지향의 본질과는 거리가 멀다.
- 객체지향 패러다임으로 전환하기 위해서는 클래스가 아닌 객체에 초점을 맞춰야 한다.

- 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체가 필요한지 고민하라.
  - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
  - 클래스의 윤곽을 잡기 위해서는 먼저 객체들이 어떤 상태와 행등을 가지는지 결정해야 한다.

- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라.
  - 객체는 홀로 존재하지 않고, 다른 객체에게 도움을 주거나 의존하며 살아가는 협력적인 존재다.
  - 객체를 공동체의 일원으로 보는 설계는 유연하고 확장 가능하게 된다.
  - 객체를 고립적인 존재로 보지 말고 협력에 참여하는 협력자로 바라보자.
  - 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체를 타입으로 분류하자.
    - 이 타입을 기반으로 클래스를 구현하자.

### 도메인의 구조를 따르는 프로그램 구조

- 도메인(domain): 사용자가 문제를 해결하기 위해 프로그램을 사용하는 분야
- 객체지향 패러다임이 강력한 이유는 요구사항을 분석하는 초기 단계부터 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문이다. (?)
  - 현실 도메인을 객체를 통해 추상화하고, 이를 클래스를 통해 프로그램으로 옮기기
  - 도메인 개념을 구현하기 위해 클래스를 사용한다.

### 클래스 구현하기

- 도메인 개념들의 구조를 반영하는 클래스 구조를 만들었으면 적절한 프로그래밍 언어를 통해 이를 구현한다.
- 클래스의 경계를 구분 짓기 위해 인스턴스 변수의 가시성은 private, 메서드의 가시성은 public
  - 클래스는 내부와 외부로 구분된다.
  - 어떤 부분을 외부에 공개하고 어떤 부분을 감출지 결정해야 한다.

- 클래스의 내부와 외부를 구분해야 하는 이유는 무엇일까? 
  - 경계의 명확성이 객체의 자율성을 보장하기 때문 -> 자율적인 객체
  - 프로그래머에게 구현의 자유를 제공하기 때문 -> 프로그래머의 자유

### 자율적인 객체

- 객체에 대한 두 가지 중요한 사실
  - 객체는 **상태(state)** 와 **행동(behavior)** 를 함께 가지는 복합적인 존재다.
  - 객체는 스스로 판단하고 행동하는 **자율적인 존재**다.

- 많은 사람들은 객체를 상태와 행동을 함께 포함하는 식별 가능한 단위로 정의한다. (?)
  - 객체지향 이전의 패러다임에서는 데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램을 구성했음
  - 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶어 표현함
  - 데이터와 기능을 객체 내부로 함께 묶는 것을 **캡슐화**라고 부름

- 대부분의 객체지향 프로그래밍 언어들은 상태와 행동을 캡슐화하는 것을 지원함
  - 더 나아가 외부에서의 접근을 통제할 수 있는 **접근 제어(access control)** 매커니즘를 제공
  - 접근 제어를 위한 public, protected, private과 같은 **접근 수정자(access modifier)** 를 제공

- 객체 내부에 대한 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위해서다.
  - 객체지향의 핵심은 스스로의 상태를 관리하고, 판단하고, 행동하는 자율적인 객체들의 공동체를 구성하는 것
- 객체가 자율적인 존재가 되기 위해서는 외부의 간섭을 최소화해야 한다.
  - 외부에서는 객체가 어떤 상태에 놓여 있는지, 어떤 생각을 하고 있는지 알면 안된다.
  - 결정에 직접적으로 개입하려고 해서도 안된다.
  - 객체에 원하는 것을 요청한 뒤에는, 객체가 스스로 결정하도록 믿고 기다려야 한다.

- 객체를 두 부분으로 나누는 캡슐화와 접근 제어
  - **퍼블릭 인터페이스(public interface)**: 외부에서 접근 가능한 부분
  - **구현(implementation)**: 오직 내부에서만 접근 가능한 부분
  - **인터페이스와 구현의 분리(separation of interface and implementation)** 원칙

- 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개해야 한다.
  - 퍼블릭 인터페이스에는 public으로 지정된 메서드만 포함됨
  - private, protected 메서드, 속성은 구현에 포함됨

### 프로그래머의 자유

- 프로그래머의 역할 구분
  - **클래스 작성자(class creator)**: 새로운 데이터 타입을 프로그래머에 추가
  - **클라이언트 프로그래머(client programmer)**: 클래스 작성자가 추가한 데이터 타입을 사용

- 클라이언트 프로그래머의 목표: 필요한 클래스들을 엮어서 애플리케이션을 빠르게 구축하는 것
- 클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨겨야 한다.
  - 클라이언트 프로그래머가 숨겨 놓은 부분에 마음대로 접근할 수 없도록 방지
  - 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있음
  - **구현 은닉(implementation hiding)** 이라고 부름

- 접근 제어 매커니즘의 기능
  - 클래스의 내부 외부를 경계 지음
  - 클래스 작성자가 내부 구현을 은닉할 수 있게 함
  - 클라이언트 프로그래머가 실수로 숨겨진 부분에 접근하는 것을 막아줌 -> 컴파일 에러

- 구현 은닉은 클래스 작성자와 클라이언트 프로그래머 모두에게 유용한 개념
  - 클라이언트 프로그래머는 내부 구현은 무시한 채 인터페이스만 알고 있어도 클래스를 사용할 수 있음
  - 클래스 작성자는 인터페이스를 바꾸지 않는 한 내부 구현을 마음대로 바꿀 수 있음

- 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.

- 설계가 필요한 이유는 변경을 관리하기 위해서이다.
  - 객체지향 언어는 객체 사이의 의존성을 적절히 관리함으로써 변경에 대한 파급효과를 제어할 수 있다.
  - 객체의 변경을 관리할 수 있는 기법 중 대표적인 것이 접근 제어.
  - 변경될 가능성이 있는 세부적인 구현 내용을 private 영역 안에 감춰 변경으로 인한 혼란을 최소화하기.

### 협력하는 객체들의 공동체

- Money: 금액과 관련된 다양한 계산을 구현하는 클래스
  - 금액을 구현하기 위해 Long 타입을 사용할 수도 있음
  - 하지만 저장하는 값이 금액과 관련돼 있다는 의미를 전달할 수는 없음
  - 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것도 막을 수 없음

- 의미를 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하라.
  - 개념이 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높일 수 있다.

- **협력(Collaboration)**: 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용
  - 객체지향 프로그램을 작성할 때는 먼저 협력의 관점에서 어떤 객체가 필요한지 결정하기
  - 이후 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성

### 협력에 관한 짧은 이야기

- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청(request)** 할 수 있다.
- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답(response)** 한다.

- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송(send a message)** 하는 것 뿐이다.
- 다른 객체에게 요청이 도착할 때 해당 객체가 **메시지를 수신(receive a message)** 했다고 이야기한다.
  - 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정한다.
  - 수신된 메시지를 처리하기 위한 자신만의 방법을 **메서드(method)** 라고 부른다.

- 메시지와 메서드를 구분하는 것은 매우 중요하다.
  - 메시지와 메서드의 구분에서부터 **다형성(polymorphism)** 의 개념이 출발한다.

- '메서드를 호출한다'는 표현보다 '메시지를 전송한다'는 표현이 더 적절하다.
- 메시지를 수신한 객체는 스스로 적절한 메서드를 선택한다.

## 3. 할인 요금 구하기

### 할인 요금 계산을 위한 협력 시작하기

- 객체지향에서 가장 중요하다고 여겨지는 두 가지 개념: **상속(inheritance)**, **다형성**
  - 상속과 다형성의 기반이 되는 원리: **추상화(abstraction)**

### 할인 정책과 할인 조건

- 할인 정책: 금액 할인 정책, 비율 할인 정책
  - AmountDiscountPolicy, PercentDiscountPolicy라는 클래스로 구현
  - 두 클래스는 대부분의 코드가 유사하고 할인 요금을 계산하는 방식만 조금 다름
  - 따라서 두 클래스 사이의 중복 코드를 제거하기 위해 공통 코드를 보관할 장소가 필요함

- 부모 클래스인 DiscountPolicy 안에 중복 코드를 두고 두 클래스가 이 클래스를 상속받도록 함
  - 실제 애플리케이션에는 DiscountPolicy의 인스턴스를 생성할 필요가 없기 때문에 **추상 클래스(abstract class)** 로 구현

- **TEMPLATE METHOD** 패턴: 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임하는 디자인 패턴
  - 부모는 추상 클래스로 구현됨
  - 자식 클래스에 위임할 작업을 **추상 메서드(abstract method)** 로 선언

- **오버라이딩(overriding)** 과 **오버로딩(overloading)**
  - 오버라이딩: 부모 클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의하는 경우
    - 오버라이딩한 자식 메서드는 부모 클래스의 메서드를 가리킴
    - 외부에서는 부모 클래스의 메서드가 보이지 않음
  - 오버로딩: 메서드의 이름은 같지만 제공되는 파라미터의 목록이 다른 경우
    - 오버로딩한 메서드는 원래의 메서드를 가리지 않고 공존함

### 할인 정책 구성하기

- 생성자의 파라미터 목록을 이용해 초기화에 필요한 정보를 전달하도록 강제할 수 있다.
  - 이를 통해 올바른 상태를 가진 객체의 생성을 보장한다.

## 4. 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

- 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나, 해당 클래스의 객체의 메서드를 호출한 경우 두 클래스 사이에 의존성이 존재한다고 말한다.
- 추상 클래스에 의존하는 경우 생기는 의문점
  - 코드 작성 시점에는 추상 클래스의 구현체에 대해서 알지 못한다.
  - 하지만 실행 시점에는 구현체들과 협력이 가능하다.

- 코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있다.
  - 즉, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.

- 유연하고, 쉽게 재사용 가능하고, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.
  - 그러나 코드의 의존성과 실행 시점의 의존성이 다를 수록 코드를 이해하기 어려워진다.
  - 코드를 이해하기 위해서는 코드뿐만 아니라 객체를 생성하고 연결하는 부분을 찾아야 하기 때문이다.
  - 의존성의 양면성은 설계가 트레이드오프의 산물이라는 사실을 잘 보여준다.

- 설계가 유연해질수록 코드를 이해하고 디버깅하기는 점점 더 어려워진다.
- 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만, 재사용성과 확장 가능성은 낮아진다.
- 항상 유연성과 가독성 사이에서 고민해야 한다.
  - 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다.
  - 객체지향 설계가 어려우면서도 매력적인 이유.
