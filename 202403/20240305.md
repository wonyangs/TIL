# 운영체제 스터디
# 페이징과 스와핑

## Paging

- 메모리를 할당해주는 가장 편한 방법은 한번에 할당하는 것
  - 하지만 덩치가 클수록 문제가 많이 발생한다.

- 페이징은 메모리를 연속적이지 않게 쪼개서 관리하는 것
  - external fragmentation이 거의 발생하지 않음

### 가장 기본적인 페이징

- 고정된 크기의 physical 메모리를 쪼갠다. -> frames
- logical 메모리를 같은 크기로 쪼갠다. -> pages

- logical 메모리를 같은 위치의 physical 메모리에 매핑시킬 필요가 없어짐
  - 실제 물리적인 주소와의 매핑은 운영체제가 알아서 함

- 실제 물리적인 메모리 주소 대신 page number(p), page offset (d)를 이용해 표현이 가능해짐

### page number

![](../resources/2024-03-05-14-30-32.png)

- CPU가 logical 주소를 만들면 physical 주소로 변환됨
- 페이지 번호에 해당하는 페이지 프레임의 오프셋을 가지고 주소를 찾을 수 있다.

- 프레임 크기를 정하는 것도 중요함
  - 하드웨어에 따라 정의됨
  - 반드시 2의 배수로 해야됨

### Hardware Support

- page table도 context switch의 대상이 된다.
- 메모리를 많이 사용하는 프로세스는 page table의 크기도 매우 크다.
  - 관리하기 어려움

### PTBR (page-table base register)

- page table을 가리키는 레지스터
- context switch가 빨라짐
- memory 접근을 두번 해야하기 때문에 접근 속도가 느려짐
  - 페이지 테이블 목록 -> 실제 메모리

### Translation Look-aside Buffer (TLB)

- page table로 찾는 것이 비용이 많이 들기 때문에 캐시를 둔다.
- 아주 작고 빠른 하드웨어 캐시 메모리를 사용
- 히트가 되면 바로 접근하여 빠른 속도를 제공
  - TLB hit: TLB에 페이지 번호가 있는 경우
  - TLB miss: TLB에 페이지 번호가 없는 경우

### Memory Protection with Paging

- 각 프레임 별로 valid-invalid bit를 두어 확인
  - bit가 valid로 세팅되어 있으면 legal하다고 판단
  - bit가 invalid로 세팅되어 있으면 illegal하다고 판단

### Shared Pages

- 페이징을 통해 공통의 코드를 공유하기 좋다.
- libc의 예시
  - 모든 프로세스가 각자 libc를 가지고 있다면 매우 비효율적일 것이다.
  - reentrant code로 설정함 -> 실행 중에 변경될 일이 없는 코드

- 물리적인 주소에는 딱 하나만 할당되어 있음
  - 논리적 주소만 복사함
  - 읽기 작업만 하기 때문에 동시성 문제가 발생하지 않음

## Page Table 구조

- Hierarchical Paging
  - page table의 page table을 만들음
- Hashed Page Tables
  - 해시 함수를 통해 hash table을 사용해 탐색
  - 가상 page 번호를 관리
- Inverted Page Tables
  - pid와 페이지 번호를 함께 저장
  - 페이저 번호 자체가 너무 클 때 사용

## Swapping

- physical 메모리보다 큰 메모리가 필요한 프로그램도 실행시킬 수 있다.
  - 프로그램 전체가 다 로딩될 필요가 없기 때문
- 멀티 프로그래밍 할 수 있는 프로세스 수가 늘어남
- 메모리에 access할 때만 들어와라

### Standard Swapping

- 프로세스 전체를 swap out 시키고 swap in 시키는 것

### Swapping with Paging

- page 단위로 swap out, swap in을 하는 것
- 오늘날 swapping을 paging이라고 부름
  - page in, page out이라고 부름
- 가상 메모리에서 큰 위력을 발휘함